#include <Arduino.h>
#include <ArduinoSTL.h>

//IMPORTANT: Due to support limitations of the library "ArduinoSTL", the code is not compatible with other platforms than AtmelAVR
//please visit https://docs.platformio.org/en/latest/boards/index.html, to check if your device is supported.

{typedefinitions}

std::vector<FEATURE_TYPE> v;
String incomingByte;
std::vector<FEATURE_TYPE> data;
std::vector<LABEL_TYPE> result;
 


//checks if Arduino::String is a float.
//@defragster https://forum.pjrc.com/index.php?threads/testing-if-a-string-is-numeric.27842/#post-65572

void printVector(std::vector<OUTPUT_TYPE> v){
  for (unsigned int i = 0; i < v.size(); i++) {
    Serial.print(v[i]);
    Serial.print(" ");
  }
  Serial.println("---"); //to indicate that output is over
}

int vectorArgmax(const std::vector<OUTPUT_TYPE>& vector) {
    if (vector.empty()) {
        return -1;
    }
    
    OUTPUT_TYPE maxVal = vector[0];
    int maxIndex = 0;
    
    for (size_t i = 1; i < vector.size(); i++) {
        if (vector[i] > maxVal) {
            maxVal = vector[i];
            maxIndex = i;
        }
    }
    
    return maxIndex;
}

bool isNumeric(const char* str) {
  byte ii = 0;
  bool RetVal = false;
  if ( '-' == str[ii] )
    ii++;
  while (str[ii])
  {
    if ( '.' == str[ii] ) {
      ii++;
      break;
    }
    if (!isdigit(str[ii])) return false;
    ii++;
    RetVal = true;
  }
  while (str[ii])
  {
    if (!isdigit(str[ii])) return false;
    ii++;
    RetVal = true;
  }
  return RetVal;
}

std::vector<FEATURE_TYPE> read_uart() {
  // Read bytes and accumulate them into a buffer
  v.clear();
  String buffer = "";
  int featureCounter = 0;
  while (Serial.available() > 0) {
    float byteRead = Serial.parseFloat();
    //if (byteRead == '\n') { // End of string marker
      v.push_back(byteRead);
      featureCounter++;
      //buffer = "";
      //byteRead = "";
      if(featureCounter >= AMOUNT_FEATURES){
          break;
      }
    //}
    //buffer += byteRead;
  }
  
  /*
  // Process the buffer
  v.clear();
  while (buffer.length() > 0) {
    float parsedValue;
    while (Serial.available() > 0) {
      parsedValue = Serial.parseFloat();
       if (parsedValue != NAN) {
       break;
      }
}
    if (parsedValue != NAN) { // Data parsed successfully
      v.push_back(parsedValue); // Assuming FEATURE_TYPE is float
    } else {
      Serial.println("Error: Failed to parse float value");
      break;
    }

    // Remove parsed value from buffer
    int parsedIndex = buffer.indexOf(' ');
    if (parsedIndex == -1) {
      buffer = ""; // No more values
    } else {
      buffer = buffer.substring(parsedIndex + 1);
    }
  }
  */

  return v;
}


void setup() {
  Serial.begin(9600);
  Serial.print("connected");
}

void loop() {
    incomingByte = "";
    data = read_uart();
	if(data.size()>0){
    //printVector(data);
		result = predict(data);
		//printVector(result);
    Serial.println(vectorArgmax(result));
    data.clear();
	}
}